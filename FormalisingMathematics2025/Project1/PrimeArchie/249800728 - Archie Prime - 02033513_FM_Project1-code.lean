/-
Project 1 - Formalising Mathematics
-/

import Mathlib.Tactic
import Mathlib.Algebra.Group.Defs
import Mathlib.Data.List.Basic

/-!
# Year 1 Problem Sheet Question
Based on Group Theory.

## Aims
Define:
1. H is a subgroup of G
2. The intersection of two subgroups
3. The join of two subgroups
Justify:
1. The intersection of two subgroups of G, H and F, is the largest subgroup contained in
both H and F.
2. The join function is associative.

For the definitions, it is necessary to prove that the intersection and join of two subgroups
is a subgroup.

We will start by first defining a group:

## Definition of a Group
-/

/-- A `group` structure on a type `G` under `*` is multiplication, identity and inverse,
so we define them: -/
class mygroup (G : Type) extends One G, Mul G, Inv G : Type where
(mul_assoc : ∀ a b c : G, (a * b) * c = a * (b * c))
(one_mul : ∀ a : G, 1 * a = a)
(mul_one : ∀ a : G, a * 1 = a)
(inv_mul_self : ∀ a : G, a⁻¹ * a = 1)
(mul_inv_self : ∀ a : G, a * a⁻¹ = 1)

/-
To drop the `mygroup` prefix, we move to a namespace called `mygroup`.
-/

namespace mygroup

variable {G : Type} [mygroup G] -- defining a group `G` in the namespace


/-!
We will now introduce subgroups

## Definition of a Subgroup
-/

/--
A `mysubgroup G` structure with `*` as multiplication, is a subset of a group `G` that is
 closed under `*` and inverses, and contains the identity element.
 -/
structure mysubgroup (G : Type) [mygroup G] where
/-- The set of elements that make up the subgroup -/
carrier : Set G -- subset of G

--the three subgroup axioms
mul_mem : ∀ {a b : G}, a ∈ carrier → b ∈ carrier → a * b ∈ carrier
one_mem : 1 ∈ carrier
inv_mem : ∀ {x : G}, x ∈ carrier → x⁻¹ ∈ carrier



/-!
We will now introduce the intersection of two subgroups

## Definition of a intersection of subgroups
-/
/-- Defining the intersection of two subgroups `H` and `K`, and proving it is a subgroup. -/
def mysubgroup_inter (H K : mysubgroup G) : mysubgroup G :=
{ carrier := H.carrier ∩ K.carrier, -- Elements that are in both H and K
  mul_mem := by -- Closure under multiplication
    intro a b ha hb
    exact ⟨H.mul_mem ha.1 hb.1, K.mul_mem ha.2 hb.2⟩

  one_mem := by
    exact ⟨H.one_mem, K.one_mem⟩ -- 1 is in both

  inv_mem := by
    intro a ha
    exact ⟨H.inv_mem ha.1, K.inv_mem ha.2⟩ -- Closure under inverses
}

/--
Notation for the intersection of two subgroups `H` and `K`.
-/
notation H " ⊓ " K => mysubgroup_inter H K

/-- The intersection `H ⊓ K` is the largest subgroup contained in both `H` and `K`. -/
lemma mysubgroup_inter_largest (H K S : mysubgroup G)
  (hH : S.carrier ⊆ H.carrier)
  (hK : S.carrier ⊆ K.carrier) :
  S.carrier ⊆ (H ⊓ K).carrier := by
  intro x hx
  exact ⟨hH hx, hK hx⟩


/-!
We will now introduce the join of two subgroups

## Definition of a join of two subgroups

Before we can define the join of two subgroups, it is necessary to define a similar function to
that of Subgroup.closuer in mathlib.
This function takes the carriers (elements) of two `mysubgroup`s and returns the group generated
by them.
-/

/-- The subgroup generated by the union of two subgroup carriers. -/
def mysubgroup_closure (S : Set G) : mysubgroup G :=
--takes all elements made by the product of a finite sequence of elements in the subset
--`foldr` returns the product from left to right of the list `a`
{ carrier := { x | ∃ a : List G, a.foldr (· * ·) 1 = x ∧ ∀ b ∈ a, b ∈ S},
  one_mem := by
    exact ⟨[], by simp⟩,
  mul_mem := by
    sorry
  inv_mem := by
    sorry
}

/--
  `mysubgroup_join H K` is the smallest subgroup that contains both `H` and `K`.
  It is defined as the subgroup closure of the union of their elements.
  This corresponds to the join of `H` and `K` in the lattice of subgroups.
-/
def mysubgroup_join (H K : mysubgroup G) : mysubgroup G :=
  mysubgroup_closure (H.carrier ∪ K.carrier)

/--
Notation for the join of two subgroups `H` and `K`.
-/
notation H " ⊔ " K => mysubgroup_join H K

/-- The lemma that states that two subgroups are equal if and only if their carriers are equal. -/
lemma mysubgroup_eq_iff (H K : mysubgroup G) : (H = K) ↔ (H.carrier = K.carrier) := by
  constructor
  intro h
  rw [h]
  intro h
  cases H
  cases K
  congr


/-- Proving that join is associative: `(H ⊔ K) ⊔ L = H ⊔ (K ⊔ L)` -/
lemma join_associative (H K L : mysubgroup G) : ((H ⊔ K) ⊔ L) = (H ⊔ (K ⊔ L)) := by
  sorry

/-!
  apply mysubset_antisymm,

  -- Prove that (H ⊔ K) ⊔ L ⊆ H ⊔ (K ⊔ L)
  { intro x hx,
    obtain ⟨hx1, hx2⟩ := hx,  -- Breaking (H ⊔ K) ⊔ L into two parts
    obtain ⟨hx1a, hx1b⟩ := hx1,  -- Breaking (H ⊔ K) into two parts
    cases hx1a with h1 h2, -- Case analysis on hx1a
    { -- Case 1: x ∈ H
      left, exact h1 },
    { -- Case 2: x ∈ K
      right, left, exact h2 },
    cases hx1b with h1 h2, -- Case analysis on hx1b
    { -- Case 3: x ∈ L
      right, right, exact h1 },
    { -- Case 4: x ∈ (H ⊔ K)
      left, exact h2 }
  },

  -- Prove that H ⊔ (K ⊔ L) ⊆ (H ⊔ K) ⊔ L
  { intro x hx,
    obtain ⟨hx1, hx2⟩ := hx,  -- Breaking H ⊔ (K ⊔ L) into two parts
    cases hx1 with h1 h2,  -- Case analysis on hx1
    { -- Case 1: x ∈ H
      left, left, exact h1 },
    { -- Case 2: x ∈ (K ⊔ L)
      right, cases hx2 with h2a h2b,
      { -- Case 2.1: x ∈ K
        left, right, exact h2a },
      { -- Case 2.2: x ∈ L
        right, right, exact h2b } }
  }
-/

-- Lemma: If the union of two subgroups is a subgroup, one must be contained within the other.
-- I wanted to prove this but ran out of time
lemma union_of_subgroups_is_subgroup_implies_containment (H K : mysubgroup G) (a b : G) :
((1 ∈ H.carrier ∪ K.carrier)∧(a ∈ H.carrier ∪ K.carrier → a⁻¹ ∈ H.carrier ∪ K.carrier) ∧
((a ∈ H.carrier ∪ K.carrier ∧ b ∈ H.carrier ∪ K.carrier) → (a * b) ∈ H.carrier ∪ K.carrier))
→ (H.carrier ⊆ K.carrier ∨ K.carrier ⊆ H.carrier) := by
  sorry

end mygroup
#lint
