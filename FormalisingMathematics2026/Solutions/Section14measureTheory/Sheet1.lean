/-
Copyright (c) 2025 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, Kevin Buzzard
-/
import Mathlib.Tactic
-- imports all the Lean tactics
import Mathlib.MeasureTheory.MeasurableSpace.Defs

/-

# Measure theory

## Sigma algebras.

A Ïƒ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/

namespace Section13Sheet1

-- let X be a set
variable (X : Type)

-- ...and let ğ“ be a sigma-algebra on X
variable (ğ“ : MeasurableSpace X)

/-

Note that `MeasurableSpace` is a *class*, so really we should be writing `[MeasurableSpace X]`,
meaning "let `X` be equipped once and for all with a sigma algebra which we won't give a name to".
But in this sheet we'll consider making them explicitly.

Let's do the following exercise. Show that if `A` is a subset of `X` then `{0,A,Aá¶œ,X}`
is a sigma algebra on `X`.

-/
def genBy (A : Set X) : MeasurableSpace X where
  MeasurableSet' S := S = âˆ… âˆ¨ S = A âˆ¨ S = Aá¶œ âˆ¨ S = Set.univ
  measurableSet_empty := by simp
  measurableSet_compl := by
    rintro s (rfl | rfl | rfl | rfl) <;> simp
  measurableSet_iUnion f hf := by
    by_cases h_univ : âˆƒ i, f i = Set.univ
    Â· right; right; right; rcases h_univ with âŸ¨i, hiâŸ©
      exact Set.univ_subset_iff.mp (hi â–¸ Set.subset_iUnion f i)
    push_neg at h_univ
    by_cases h_both : (âˆƒ i, f i = A) âˆ§ (âˆƒ j, f j = Aá¶œ)
    Â· right; right; right; rcases h_both with âŸ¨âŸ¨i, hiâŸ©, âŸ¨j, hjâŸ©âŸ©
      apply Set.univ_subset_iff.mp
      intro x _
      by_cases hx : x âˆˆ A
      Â· exact Set.mem_iUnion.mpr âŸ¨i, hi.symm â–¸ hxâŸ©
      Â· exact Set.mem_iUnion.mpr âŸ¨j, hj.symm â–¸ hxâŸ©
    Â· by_cases h_A : âˆƒ i, f i = A
      Â· right; left; apply Set.Subset.antisymm
        Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨i, hiâŸ©
          rcases hf i with rfl | rfl | rfl | rfl
          Â· contradiction
          Â· assumption
          Â· exfalso; apply h_both; exact âŸ¨h_A, âŸ¨i, rflâŸ©âŸ©
          Â· contradiction
        Â· rcases h_A with âŸ¨i, hiâŸ©; rw [â† hi]; exact Set.subset_iUnion f i
      Â· by_cases h_Ac : âˆƒ i, f i = Aá¶œ
        Â· right; right; left; apply Set.Subset.antisymm
          Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨i, hiâŸ©
            rcases hf i with rfl | rfl | rfl | rfl
            Â· contradiction
            Â· exfalso; apply h_A; exact âŸ¨i, rflâŸ©
            Â· assumption
            Â· contradiction
          Â· rcases h_Ac with âŸ¨i, hiâŸ©; rw [â† hi]; exact Set.subset_iUnion f i
        Â· left; apply Set.Subset.antisymm
          Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨i, hiâŸ©
            rcases hf i with rfl | rfl | rfl | rfl
            Â· contradiction
            Â· exfalso; apply h_A; exact âŸ¨i, rflâŸ©
            Â· exfalso; apply h_Ac; exact âŸ¨i, rflâŸ©
            Â· contradiction
          Â· exact Set.empty_subset _

-- An alternative approach to defining the sigma algebra generated by `{A}` is just
-- to use `MeasurableSpace.generateFrom`:
example (A : Set X) : MeasurableSpace X :=
  MeasurableSpace.generateFrom {A}

-- But the problem with that approach is that you don't get the actual sets
-- in the sigma algebra for free. Try this, to see what I mean!
example (A : Set X) :
    (MeasurableSpace.generateFrom {A}).MeasurableSet' =
    ({âˆ…, A, Aá¶œ, Set.univ} : Set (Set X)) := by
  ext S
  constructor
  Â· intro h
    induction h with
    | basic s hs => simp at hs; subst hs; simp
    | empty => simp
    | compl s hs ih => rcases ih with rfl | rfl | rfl | rfl <;> simp
    | iUnion f hf ih =>
      by_cases h_univ : âˆƒ i, ih i = Set.univ
      Â· rcases h_univ with âŸ¨i, hiâŸ©
        have : (â‹ƒ i, f i) = Set.univ := Set.univ_subset_iff.mp (hi â–¸ Set.subset_iUnion f i)
        rw [this]; simp
      push_neg at h_univ
      by_cases h_both : (âˆƒ i, ih i = A) âˆ§ (âˆƒ j, ih j = Aá¶œ)
      Â· rcases h_both with âŸ¨âŸ¨i, hiâŸ©, âŸ¨j, hjâŸ©âŸ©
        have : (â‹ƒ i, f i) = Set.univ := by
          apply Set.univ_subset_iff.mp; intro x _
          by_cases hx : x âˆˆ A
          Â· exact Set.mem_iUnion.mpr âŸ¨i, hi.symm â–¸ hxâŸ©
          Â· exact Set.mem_iUnion.mpr âŸ¨j, hj.symm â–¸ hxâŸ©
        rw [this]; simp
      Â· by_cases h_A : âˆƒ i, ih i = A
        Â· have : (â‹ƒ i, f i) = A := by
            apply Set.Subset.antisymm
            Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨k, hkâŸ©
              specialize ih k; rcases ih with rfl | rfl | rfl | rfl
              Â· contradiction
              Â· exact hk
              Â· exfalso; apply h_both; exact âŸ¨h_A, âŸ¨k, rflâŸ©âŸ©
              Â· contradiction
            Â· rcases h_A with âŸ¨i, hiâŸ©; rw [â† hi]; exact Set.subset_iUnion f i
          rw [this]; simp
        Â· by_cases h_Ac : âˆƒ i, ih i = Aá¶œ
          Â· have : (â‹ƒ i, f i) = Aá¶œ := by
              apply Set.Subset.antisymm
              Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨k, hkâŸ©
                specialize ih k; rcases ih with rfl | rfl | rfl | rfl
                Â· contradiction
                Â· exfalso; apply h_A; exact âŸ¨k, rflâŸ©
                Â· exact hk
                Â· contradiction
              Â· rcases h_Ac with âŸ¨i, hiâŸ©; rw [â† hi]; exact Set.subset_iUnion f i
            rw [this]; simp
          Â· have : (â‹ƒ i, f i) = âˆ… := by
              apply Set.Subset.antisymm
              Â· rintro x hx; rcases Set.mem_iUnion.mp hx with âŸ¨k, hkâŸ©
                specialize ih k; rcases ih with rfl | rfl | rfl | rfl
                Â· contradiction
                Â· exfalso; apply h_A; exact âŸ¨k, rflâŸ©
                Â· exfalso; apply h_Ac; exact âŸ¨k, rflâŸ©
                Â· contradiction
              Â· exact Set.empty_subset _
            rw [this]; simp
  Â· rintro (rfl | rfl | rfl | rfl)
    Â· exact MeasurableSpace.measurableSet_empty _
    Â· apply MeasurableSpace.GenerateMeasurable.basic; simp
    Â· apply MeasurableSpace.measurableSet_compl
      apply MeasurableSpace.GenerateMeasurable.basic; simp
    Â· exact MeasurableSpace.measurableSet_univ _

end Section13Sheet1